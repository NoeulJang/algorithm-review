#Chapter-2 [디버깅]은 디버깅의 중요성에 대한 설명으로 건너뜀

chapter-3 [자료구조]
  
1. 배열(Array)
  
1) 인덱스 있음
2) 새 값 삽입/제거가 어려움. 삽입/제거 시 주변값을 이동시키는 과정 필요
3) 배열의 크기는 선언할 때 지정가능, 한 번 선언 시 크기를 늘리거나 줄이기 불가

2. 리스트(List)

1) 인덱스 없음
2) 조회 시 head 포인터 부터 순서대로 접근(조회속도 느림)
3) 데이터 추가/삽입/제거가 빠름
4) 리스트의 크기 선언 필요 X
5) 배열보다 구조가 복잡

3. ArrayList

1) 인덱스 있음
2) 가변배열
3) 삽입/제거가 용이하나 삽입/제거 시 객체 전체가 이동함 (LinkedList 보다 안 좋음)
4) 조회가 빠름(LinkedList 보다 좋음)
  
4. LinkedList

1) 인덱스 있음
2) 데이터의 추가, 삽입, 삭제가 쉬움
3) 현재 노드가 가지고 있는 포인터 정보를 사용하여 추가적인 연산 없이 다음 노드를 가져올 수 있음 그러나, 다음 노드를 가르키는 포인터가 필요하기 때문에 메모리가 추가로 필요
4) 헤드 노드의 정보만 가지고 있기 때문에 특정 위치에 있는 노드를 탐색하는데 많은 연산이 필요함

5. 숫자합 - 생략

6. 평균 - 간단하더라도 시간 복잡도를 고려하여 연산 로직을 간소화 시키는 것이 중요

7. 구간합 

  # 합배열을 만들 땐, 인덱스 0 번째는 0으로 주고 1부터 구간합을 계산해 넣어야 계산이 편함, 그러므로 배열 크기 선언 시 N + 1로 선언 
  # S = 합 배열, A = 주어진 배열, i = 구해야할 현재 구간(문제에서 2번째 라면 실제 인덱스(i)는 = 3) 
1) 합 배열 공식 : S[i] = S[i-1] + A[i]
  - 합 배열[전 인덱스] + 현재 배열[현재 인덱스] (그냥 여태 구해왔던거에 현재 값을 더한다고 이해함)

2) 구간 합 공식 : S[j] - S[i-1]
  - 합 배열[구해야 할 최소 구간 인덱스] - 합 배열[구해야 할 최고구간 인덱스] (말로 설명하기가 참 어렵다. 아무튼 현재 구간만 남기고 전 구간들을 제거한다고 이해함)

3) 2차원 구간 합 배열 공식 : D[i][j] = D[i][j-1] + D[i-1][j] - D[i-1][j-1] + A[i][j]
  - 계산해야 할 구간 합의 인덱스가 (2,3)이라면 2,3의 바로 위(1,3)와 바로 왼쪽(2,2)을 더하고 그 뺀 두 구간의 중복된 구간을 다시 빼준 뒤에 현재 값을 더하면 됨. 사은품은 1인당 하나만이니까.

4) 2차원 구간 합 공식 : D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]
  - 구해야 할 최종 구간에서 바로 윗구간, 왼쪽구간을 빼고나서 중복된 구간을 다시 더해주면 됨. 사은품 2개 받았다고 2개다 뺏어가면 억울하니까.

8. 나머지합 - 이해중
